import os
import subprocess
import psutil
import hashlib
import tarfile
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from dotenv import load_dotenv
from datetime import datetime, timedelta

load_dotenv()
bot = Bot(token=os.getenv("BOT_TOKEN"))
dp = Dispatcher()

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
SERVICES = ["cron", "ssh", "sysstat", "mysql"]
AUTH_DURATION = timedelta(hours=1)
SESSIONS = {}  # user_id: expiry_datetime

def is_authenticated(user_id: int) -> bool:
    return user_id in SESSIONS and SESSIONS[user_id] > datetime.now()

def validate(user_id: int, chat_id: int) -> bool:
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤ –õ–° ‚Äî —Ç–æ–ª—å–∫–æ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
    if chat_id == user_id:
        return is_authenticated(user_id)
    # –í –≥—Ä—É–ø–ø–∞—Ö ‚Äî –ø–æ ID
    allowed_user_ids = list(map(int, os.getenv("ALLOWED_USER_IDS", "").split(',')))
    allowed_chat_ids = list(map(int, os.getenv("ALLOWED_CHAT_IDS", "").split(',')))
    return (user_id in allowed_user_ids) and (chat_id in allowed_chat_ids)

@dp.message(Command("auth"))
async def auth_command(message: types.Message):
    if message.chat.type != "private":
        await message.answer(
        "üîê –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –≤–æ–∑–º–æ–∂–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –õ–° –±–æ—Ç–∞. –ü–µ—Ä–µ–π—Ç–∏ –≤ –õ–°: "
        "[–ù–∞–ø–∏—Å–∞—Ç—å –±–æ—Ç—É](https://t.me/Satieva4431Bot?start)")
        return

    parts = message.text.strip().split(maxsplit=1)
    if len(parts) < 2:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å, –Ω–∞–ø—Ä–∏–º–µ—Ä:\n<code>/auth mypassword</code>", parse_mode="HTML")
        return

    input_password = parts[1].strip()
    input_hash = hashlib.md5(input_password.encode()).hexdigest()
    correct_hash = os.getenv("BOT_PASSWORD_HASH")

    if input_hash == correct_hash:
        SESSIONS[message.from_user.id] = datetime.now() + AUTH_DURATION
        await message.answer("‚úÖ –£—Å–ø–µ—à–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è. –î–æ—Å—Ç—É–ø –∞–∫—Ç–∏–≤–µ–Ω –Ω–∞ 1 –¥–µ–Ω—å.")
    else:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å.")

@dp.message(Command("start"))
async def start(message: types.Message):
    if not validate(message.from_user.id, message.chat.id):
        await message.answer("‚õîÔ∏è –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.")
        return
    await message.answer("üöÄ –ë–æ—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Ä–≤–µ—Ä–æ–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!")

@dp.message(Command("disk"))
async def disk_usage(message: types.Message):
    if not validate(message.from_user.id, message.chat.id):
        await message.answer("‚õîÔ∏è –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.")
        return
    result = subprocess.run(["df", "-h"], capture_output=True, text=True)
    await message.answer(f"<pre>{result.stdout}</pre>", parse_mode="HTML")

@dp.message(Command("service_status"))
async def service_status(message: types.Message):
    if not validate(message.from_user.id, message.chat.id):
        await message.answer("‚õîÔ∏è –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.")
        return
    parts = message.text.strip().split(maxsplit=1)

    if len(parts) < 2 or not parts[1].strip():
        await message.answer("‚ùóÔ∏è –ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–∞ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä:\n<code>/service_status nginx</code>", parse_mode="HTML")
        return

    service_name = parts[1].strip()

    try:
        result = subprocess.run(
            ["systemctl", "status", service_name],
            capture_output=True,
            text=True,
            check=True  # –í —Å–ª—É—á–∞–µ –ø–æ–ª–æ–º–∫–∏ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç –∏—Å–∫–ª—é—á–µ–Ω–∏–µ
        )
        await message.answer(f"<code>{result.stdout}</code>", parse_mode="HTML")

    except subprocess.CalledProcessError as e:
        # –í —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç:
        error_output = e.stderr or e.stdout or "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–∏—Å–∞."
        await message.answer(f"‚ùóÔ∏è –û—à–∏–±–∫–∞: <code>{error_output.strip()}</code>", parse_mode="HTML")

@dp.message(Command("ping"))
async def ping_host(message: types.Message):
    if not validate(message.from_user.id, message.chat.id):
        await message.answer("‚õîÔ∏è –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.")
        return
    parts = message.text.strip().split(maxsplit=1)

    if len(parts) < 2 or not parts[1].strip():
        await message.answer("‚ùóÔ∏è –ù–∞–ø–∏—à–∏—Ç–µ –∞–¥—Ä–µ—Å –¥–ª—è –ø–∏–Ω–≥–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä:\n<code>/ping google.com</code>", parse_mode="HTML")
        return

    host = parts[1].strip()

    try:
        result = subprocess.run(
            ["ping", "-c", "4", host],  # –û—Ç–ø—Ä–∞–≤–∫–∞ 4 –ø–∞–∫–µ—Ç–æ–≤ ping
            capture_output=True,
            text=True,
            timeout=10
        )
        if result.returncode == 0:
            await message.answer(f"<code>{result.stdout}</code>", parse_mode="HTML")
        else:
            await message.answer(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–ø–∏–Ω–≥–æ–≤–∞—Ç—å <b>{host}</b>.\n<code>{result.stderr or result.stdout}</code>", parse_mode="HTML")

    except subprocess.TimeoutExpired:
        await message.answer(f"‚è±Ô∏è –ü–∏–Ω–≥ –¥–æ <b>{host}</b> –∑–∞–Ω—è–ª —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ (—Ç–∞–π–º–∞—É—Ç).", parse_mode="HTML")
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –ø–∏–Ω–≥–∞: <code>{str(e)}</code>", parse_mode="HTML")

@dp.message(Command("usage"))
async def system_usage(message: types.Message):
    if not validate(message.from_user.id, message.chat.id):
        await message.answer("‚õîÔ∏è –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.")
        return
    # –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞ –∏ –û–ó–£
    cpu_percent = psutil.cpu_percent(interval=1)
    ram = psutil.virtual_memory()
    ram_used = ram.used / (1024 ** 3)
    ram_total = ram.total / (1024 ** 3)
    ram_percent = ram.percent

    response = (
        f"üìä <b>–°–∏—Å—Ç–µ–º–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã:</b>\n"
        f"üß† CPU: <b>{cpu_percent}%</b>\n"
        f"üíæ RAM: <b>{ram_used:.2f} GB</b> / <b>{ram_total:.2f} GB</b> ({ram_percent}%)"
    )

    await message.answer(response, parse_mode="HTML")


@dp.message(Command("main_services_status"))
async def main_services_status(message: types.Message):
    if not validate(message.from_user.id, message.chat.id):
        await message.answer("‚õîÔ∏è –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.")
        return
    status_lines = ["üìã <b>–°—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–∏—Å–æ–≤:</b>"]


    for service in SERVICES:
        result = subprocess.run(
            ["systemctl", "is-active", service],
            capture_output=True,
            text=True
        )
        status = result.stdout.strip()
        if status == "active":
            status_lines.append(f"‚úÖ <b>{service}</b>")
        else:
            status_lines.append(f"‚ùå <b>{service}</b> ({status})")

    await message.answer("\n".join(status_lines), parse_mode="HTML")

@dp.message(Command("restart_service"))
async def restart_service(message: types.Message):
    if not validate(message.from_user.id, message.chat.id):
        await message.answer("‚õîÔ∏è –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.")
        return
    parts = message.text.strip().split(maxsplit=1)

    if len(parts) < 2 or not parts[1].strip():
        await message.answer("‚ùóÔ∏è –ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–∞ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä:\n<code>/restart_service nginx</code>", parse_mode="HTML")
        return

    service_name = parts[1].strip()

    try:
        # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å–ª—É–∂–±—ã —Å –ø–æ–º–æ—â—å—é systemctl restart
        result = subprocess.run(
            ["sudo", "systemctl", "restart", service_name],
            capture_output=True,
            text=True
        )

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ —Å–ª—É–∂–±—ã:
        if result.returncode == 0:
            await message.answer(f"‚úÖ –°–µ—Ä–≤–∏—Å <b>{service_name}</b> —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω!", parse_mode="HTML")
        else:
            await message.answer(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–µ—Ä–≤–∏—Å <b>{service_name}</b>.\n<code>{result.stderr or result.stdout}</code>", parse_mode="HTML")

    except subprocess.CalledProcessError as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ —Å–µ—Ä–≤–∏—Å–∞: <code>{str(e)}</code>", parse_mode="HTML")
    except Exception as e:
        await message.answer(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: <code>{str(e)}</code>", parse_mode="HTML")

@dp.message(Command("traceroute"))
async def traceroute(message: types.Message):
    if not validate(message.from_user.id, message.chat.id):
        await message.answer("‚õîÔ∏è –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.")
        return
    parts = message.text.strip().split(maxsplit=1)
    if len(parts) < 2 or not parts[1].strip():
        await message.answer("‚ùóÔ∏è –ù–∞–ø–∏—à–∏—Ç–µ –∞–¥—Ä–µ—Å –¥–ª—è —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä:\n<code>/traceroute google.com</code>", parse_mode="HTML")
        return

    host = parts[1].strip()

    try:
        result = subprocess.run(
            ["traceroute", host],
            capture_output=True,
            text=True,
            timeout=10
        )
        await message.answer(f"üîç –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –º–∞—Ä—à—Ä—É—Ç–∞ –¥–æ <b>{host}</b>:\n<pre>{result.stdout}</pre>", parse_mode="HTML")
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–µ –º–∞—Ä—à—Ä—É—Ç–∞: <code>{str(e)}</code>", parse_mode="HTML")

@dp.message(Command("backup"))
async def backup_configs(message: types.Message):
    user_id = message.from_user.id
    if not validate(user_id, message.chat.id):
        await message.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.")
        return

    config_paths = os.getenv("BACKUP_FILES", "").split(",")
    backup_dir = os.getenv("BACKUP_DIR", "/tmp")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"backup_{timestamp}.tar.gz"
    archive_path = os.path.join(backup_dir, archive_name)

    os.makedirs(backup_dir, exist_ok=True)

    try:
        with tarfile.open(archive_path, "w:gz") as archive:
            for path in config_paths:
                path = path.strip()
                if os.path.exists(path):
                    archive.add(path, arcname=os.path.basename(path))
                else:
                    await message.answer(f"‚ö†Ô∏è –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {path}")

        await message.answer("‚úÖ –ë—ç–∫–∞–ø —Å–æ–∑–¥–∞–Ω. –ê—Ä—Ö–∏–≤ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤–∞–º –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è.")

        try:
            await bot.send_document(user_id, types.FSInputFile(archive_path), caption="üì¶ –†–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏")
        except aiogram.exceptions.TelegramForbiddenError:
            await message.answer("‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—ã –Ω–∞—á–∞–ª–∏ —á–∞—Ç —Å –±–æ—Ç–æ–º (–Ω–∞–∂–º–∏—Ç–µ /start –≤ –õ–°).")

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –±—ç–∫–∞–ø–∞: <code>{str(e)}</code>", parse_mode="HTML")

if __name__ == "__main__":
    dp.run_polling(bot)
